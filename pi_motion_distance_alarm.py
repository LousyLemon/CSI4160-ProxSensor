# pi_motion_distance_alarm.pyimport RPi.GPIO as GPIOfrom datetime import datetimeimport time, os, sqlalchemy, pymysql# Import GCP requirementsfrom google.cloud import pubsub_v1from google.cloud.sql.connector import ConnectorGPIO.setmode(GPIO.BCM)# Declare Raspberry Pi GPIO PinsPIR = 4 #Physical pin: 7TRIG = 17 #Physical pin: 11ECHO = 27 #Physical pin: 13TIME_THRESHOLD = 10 # Measured in seconds?OUTER_RANGE_THRESHOLD = 375 # Measured in centimetersRANGE_TRIGGER = 50 # Measured in centimetersdelay = 0# Set up I/O declarationsGPIO.setup(TRIG,GPIO.OUT)GPIO.setup(ECHO,GPIO.IN)GPIO.setup(PIR,GPIO.IN)# Set initial value to false (Not measuring anything)GPIO.output(TRIG, False)# initialize connector objectconnector = Connector()os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'csi4160-pisub.json'publisher = pubsub_v1.PublisherClient()topic_path = 'projects/cheon-csi4160-f22/topics/pi-events'# Begin interations with environmentprint("Alarm system active: Monitoring Environment for threats")#Establish connection object constructiondef getconn() -> pymysql.connections.Connection:	with Connector() as connector:		conn: pymysql.connections.Connection = connector.connect(			"cheon-csi4160-f22:us-central1:cheon-4160",			"pymysql",			user="root",			password="bowers",			database="DB_ALARMS",		)	return conn# Create connection poolpool = sqlalchemy.create_engine(	"mysql+pymysql://",	creator=getconn,)def triggerAlarm(type, dist, time_to_trigger):	# Function Objectives:	# 1 - Determine Alarm type	# 2 - Prepare queries according to [1]	# 3 - Prepare message for Pub/Sub according to [1]	# 4 - Send message to Pub/Sub topic	# 5 - Connect to DB, execute query, return full table contents	print("ALARM TRIGGERED".center(40, "-"))	topic_path = 'projects/cheon-csi4160-f22/topics/pi-events'	time_now = str(datetime.now())	# [1] Determine Alarm Type	if type == 'Time-evoked':		# [2] Prepare time alarm query		insert_stmt = sqlalchemy.text(			"INSERT INTO time_alarms (time_now, min_distance) VALUES (:time_now, :min_distance)",		)		# [3] Create output message to push to pub/sub topic		data = f"{time_now} - {type} Alarm Detected - Minimum Distance: {dist}"		data = data.encode('utf-8')				# [4] Send message and show message id		print("Sending details to Pub/Sub")		print(f"Message Contents: {data}")		future = publisher.publish(topic_path, data)		print(f'Published message ID: {future.result()}')		#		if future.result() != None:#			# [5] Connect to instance, insert collected data#			with pool.connect() as db_conn:#				db_conn.execute(insert_stmt, time_now=time_now, min_distance=dist)#				# result = db_conn.execute("SELECT * FROM prox_alarms").fetchall()#				result = db_conn.execute("SELECT * FROM time_alarms").fetchall()#				for row in result:#					print(row)	# [1] Determine alarm type	elif type == 'Proximity':		# [2] prepare proximity alarm query		insert_stmt =  sqlalchemy.text(			"INSERT INTO prox_alarms (time_now, time_to_trigger) VALUES (:time_now, :time_to_trigger)",		)		# [3] Create output message to push to pub/sub topic		data = f'{time_now} - {type} Alarm Detected - Time to trigger: {time_to_trigger}'		data = data.encode('utf-8')				# [4] Send message and show message id		print("Sending details to Pub/Sub")		print(f"Message Contents: {data}")		future = publisher.publish(topic_path, data)		print(f'Published message ID: {future.result()}')#		if future.result() != None:#			# [5] Connect to instance, insert collected data#			with pool.connect() as db_conn:#				db_conn.execute(insert_stmt, time_now=time_now, time_to_trigger=time_to_trigger)#				result = db_conn.execute("SELECT * FROM prox_alarms").fetchall()#				# result = db_conn.execute("SELECT * FROM time_alarms").fetchall()#				for row in result:#					print(row)# Logic to support Ultrasonic sensorwhile True:	# Wait for the motion detector to activate before attempting to find an object	# -> pir_signal == 1	# Action taken:	# contents of reference for ultrasonic sensor	# do this until target is out of range	# if the range < 200cm then we want to start a counter	# count until time THRESHOLD	# if threshold is met / hit, then we triggerAlarm()	# Create db entry -> prepared statement	# Send message to pub/sub topic	# if the range < 50 cm then we want to trigger the alarm right away	# Range threshold	# Set pin input to variable	pir_signal=GPIO.input(PIR)#	time.sleep(0.1)	delay += 1	# If motion is detected	if pir_signal==1:		start_time = time.time() # start timer for time-based alarm		min_distance = 1000 # Set default min value for reporting purposes		try:			while True: # while PIR == Detecting				print("Motion detected - Measuring")				# When the signal is detecting something in range and moving				GPIO.output(TRIG, True)				time.sleep(0.00001)				GPIO.output(TRIG, False)								# Math to handle trig-echo time related-distance calculations				while GPIO.input(ECHO)==0:					pulse_start = time.time()				while GPIO.input(ECHO)==1:					pulse_end = time.time()				pulse_duration = pulse_end - pulse_start				distance = pulse_duration * 17150				distance = round(distance+1.15, 2)				print(f"Distance: {distance}")				# Update min distance if new measurement is smaller				if distance < min_distance:					min_distance = distance					print(f"New Minumum Distance: {min_distance}")				#Track length (in time) the loop has executed for				end_time = time.time()				time_counter = end_time - start_time				print(f"Time counter: {time_counter}")				if distance<=OUTER_RANGE_THRESHOLD and TIME_THRESHOLD<=time_counter:					print("Distance:",distance,"cm")					triggerAlarm('Time-evoked', distance, str(time_counter))					# Reset trigger variables					time_counter = 0					min_distance = 1000					pir_signal=0					break				if distance<=RANGE_TRIGGER:					triggerAlarm('Proximity', distance, time_counter)					time_counter = 0					min_distance = 1000					pir_signal=0					break					#time.sleep(2)		except KeyboardInterrupt:			GPIO.cleanup()	# If no motion is detected, print status to the terminal	# TODO - determine message to display, if any	if pir_signal==0 and delay >= 50000:		print("Motion Stopped")		delay = 0